// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sync.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Sync_ClientMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// -----------------------------
  public var content: Sync_ClientMessage.OneOf_Content? = nil

  public var resetRequest: Sync_ClientMessage.ResetRequest {
    get {
      if case .resetRequest(let v)? = content {return v}
      return Sync_ClientMessage.ResetRequest()
    }
    set {content = .resetRequest(newValue)}
  }

  public var resumeRequest: Sync_ClientMessage.ResumeRequest {
    get {
      if case .resumeRequest(let v)? = content {return v}
      return Sync_ClientMessage.ResumeRequest()
    }
    set {content = .resumeRequest(newValue)}
  }

  public var actionRequest: Sync_ClientMessage.ActionRequest {
    get {
      if case .actionRequest(let v)? = content {return v}
      return Sync_ClientMessage.ActionRequest()
    }
    set {content = .actionRequest(newValue)}
  }

  public var entityUpdateAcknowledgement: Sync_ClientMessage.EntityUpdateAcknowledgement {
    get {
      if case .entityUpdateAcknowledgement(let v)? = content {return v}
      return Sync_ClientMessage.EntityUpdateAcknowledgement()
    }
    set {content = .entityUpdateAcknowledgement(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// -----------------------------
  public enum OneOf_Content: Equatable {
    case resetRequest(Sync_ClientMessage.ResetRequest)
    case resumeRequest(Sync_ClientMessage.ResumeRequest)
    case actionRequest(Sync_ClientMessage.ActionRequest)
    case entityUpdateAcknowledgement(Sync_ClientMessage.EntityUpdateAcknowledgement)

  #if !swift(>=4.1)
    public static func ==(lhs: Sync_ClientMessage.OneOf_Content, rhs: Sync_ClientMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resetRequest, .resetRequest): return {
        guard case .resetRequest(let l) = lhs, case .resetRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeRequest, .resumeRequest): return {
        guard case .resumeRequest(let l) = lhs, case .resumeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionRequest, .actionRequest): return {
        guard case .actionRequest(let l) = lhs, case .actionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entityUpdateAcknowledgement, .entityUpdateAcknowledgement): return {
        guard case .entityUpdateAcknowledgement(let l) = lhs, case .entityUpdateAcknowledgement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Wipes server-side cache and re-syncs the data.
  /// Passing an empty map in the localTimestamps field effectively makes the server re-send the entire state.
  public struct ResetRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// IDs of all unsynced actions
    public var localActionIds: [String] = []

    /// metadata (type + id + timestamp) of every entity that the mobile app knows about
    public var metadata: Sync_ClientMessage.ResetRequest.EntityMetadata {
      get {return _metadata ?? Sync_ClientMessage.ResetRequest.EntityMetadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct EntityMetadata {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var counter: Dictionary<Int64,SwiftProtobuf.Google_Protobuf_Timestamp> = [:]

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _metadata: Sync_ClientMessage.ResetRequest.EntityMetadata? = nil
  }

  /// a lightweight way to resume a connection if the backend still keeps its state in the cache.
  public struct ResumeRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// last entity update batch processed by the client.
    public var lastProcessedEntityUpdateBatchID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ActionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionID: String = String()

    public var content: Sync_ClientMessage.ActionRequest.OneOf_Content? = nil

    public var create: Sync_ClientMessage.ActionRequest.CreateCounter {
      get {
        if case .create(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.CreateCounter()
      }
      set {content = .create(newValue)}
    }

    public var delete: Sync_ClientMessage.ActionRequest.DeleteCounter {
      get {
        if case .delete(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.DeleteCounter()
      }
      set {content = .delete(newValue)}
    }

    public var increment: Sync_ClientMessage.ActionRequest.IncrementCounter {
      get {
        if case .increment(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.IncrementCounter()
      }
      set {content = .increment(newValue)}
    }

    public var decrement: Sync_ClientMessage.ActionRequest.DecrementCounter {
      get {
        if case .decrement(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.DecrementCounter()
      }
      set {content = .decrement(newValue)}
    }

    public var setValue: Sync_ClientMessage.ActionRequest.SetCounterValue {
      get {
        if case .setValue(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.SetCounterValue()
      }
      set {content = .setValue(newValue)}
    }

    public var rename: Sync_ClientMessage.ActionRequest.RenameCounter {
      get {
        if case .rename(let v)? = content {return v}
        return Sync_ClientMessage.ActionRequest.RenameCounter()
      }
      set {content = .rename(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case create(Sync_ClientMessage.ActionRequest.CreateCounter)
      case delete(Sync_ClientMessage.ActionRequest.DeleteCounter)
      case increment(Sync_ClientMessage.ActionRequest.IncrementCounter)
      case decrement(Sync_ClientMessage.ActionRequest.DecrementCounter)
      case setValue(Sync_ClientMessage.ActionRequest.SetCounterValue)
      case rename(Sync_ClientMessage.ActionRequest.RenameCounter)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_ClientMessage.ActionRequest.OneOf_Content, rhs: Sync_ClientMessage.ActionRequest.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.create, .create): return {
          guard case .create(let l) = lhs, case .create(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.delete, .delete): return {
          guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.increment, .increment): return {
          guard case .increment(let l) = lhs, case .increment(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.decrement, .decrement): return {
          guard case .decrement(let l) = lhs, case .decrement(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.setValue, .setValue): return {
          guard case .setValue(let l) = lhs, case .setValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rename, .rename): return {
          guard case .rename(let l) = lhs, case .rename(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct IncrementCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DecrementCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct SetCounterValue {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: Int64 = 0

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct CreateCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var clientSideID: Int64 = 0

      public var name: String = String()

      public var initialValue: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DeleteCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct RenameCounter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var id: Int64 = 0

      public var newName: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct EntityUpdateAcknowledgement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var batchID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Sync_ServerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Sync_ServerMessage.OneOf_Content? = nil

  public var serverHello: Sync_ServerMessage.ServerHello {
    get {
      if case .serverHello(let v)? = content {return v}
      return Sync_ServerMessage.ServerHello()
    }
    set {content = .serverHello(newValue)}
  }

  public var resetResponse: Sync_ServerMessage.ResetResponse {
    get {
      if case .resetResponse(let v)? = content {return v}
      return Sync_ServerMessage.ResetResponse()
    }
    set {content = .resetResponse(newValue)}
  }

  public var resumeResponse: Sync_ServerMessage.ResumeResponse {
    get {
      if case .resumeResponse(let v)? = content {return v}
      return Sync_ServerMessage.ResumeResponse()
    }
    set {content = .resumeResponse(newValue)}
  }

  public var actionResponse: Sync_ServerMessage.ActionResponse {
    get {
      if case .actionResponse(let v)? = content {return v}
      return Sync_ServerMessage.ActionResponse()
    }
    set {content = .actionResponse(newValue)}
  }

  public var entityUpdateNotification: Sync_ServerMessage.EntityUpdateNotification {
    get {
      if case .entityUpdateNotification(let v)? = content {return v}
      return Sync_ServerMessage.EntityUpdateNotification()
    }
    set {content = .entityUpdateNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case serverHello(Sync_ServerMessage.ServerHello)
    case resetResponse(Sync_ServerMessage.ResetResponse)
    case resumeResponse(Sync_ServerMessage.ResumeResponse)
    case actionResponse(Sync_ServerMessage.ActionResponse)
    case entityUpdateNotification(Sync_ServerMessage.EntityUpdateNotification)

  #if !swift(>=4.1)
    public static func ==(lhs: Sync_ServerMessage.OneOf_Content, rhs: Sync_ServerMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serverHello, .serverHello): return {
        guard case .serverHello(let l) = lhs, case .serverHello(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetResponse, .resetResponse): return {
        guard case .resetResponse(let l) = lhs, case .resetResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeResponse, .resumeResponse): return {
        guard case .resumeResponse(let l) = lhs, case .resumeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionResponse, .actionResponse): return {
        guard case .actionResponse(let l) = lhs, case .actionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entityUpdateNotification, .entityUpdateNotification): return {
        guard case .entityUpdateNotification(let l) = lhs, case .entityUpdateNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct EntityBody {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var content: Sync_ServerMessage.EntityBody.OneOf_Content? = nil

    public var counter: Sync_ServerMessage.EntityBody.Counter {
      get {
        if case .counter(let v)? = content {return v}
        return Sync_ServerMessage.EntityBody.Counter()
      }
      set {content = .counter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case counter(Sync_ServerMessage.EntityBody.Counter)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_ServerMessage.EntityBody.OneOf_Content, rhs: Sync_ServerMessage.EntityBody.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.counter, .counter): return {
          guard case .counter(let l) = lhs, case .counter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public struct Counter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct EntityEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Int64 = 0

    public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    public var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    public mutating func clearTimestamp() {self._timestamp = nil}

    public var content: Sync_ServerMessage.EntityEvent.OneOf_Content? = nil

    public var create: Sync_ServerMessage.EntityEvent.Create {
      get {
        if case .create(let v)? = content {return v}
        return Sync_ServerMessage.EntityEvent.Create()
      }
      set {content = .create(newValue)}
    }

    public var update: Sync_ServerMessage.EntityEvent.Update {
      get {
        if case .update(let v)? = content {return v}
        return Sync_ServerMessage.EntityEvent.Update()
      }
      set {content = .update(newValue)}
    }

    public var delete: Sync_ServerMessage.EntityEvent.Delete {
      get {
        if case .delete(let v)? = content {return v}
        return Sync_ServerMessage.EntityEvent.Delete()
      }
      set {content = .delete(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Content: Equatable {
      case create(Sync_ServerMessage.EntityEvent.Create)
      case update(Sync_ServerMessage.EntityEvent.Update)
      case delete(Sync_ServerMessage.EntityEvent.Delete)

    #if !swift(>=4.1)
      public static func ==(lhs: Sync_ServerMessage.EntityEvent.OneOf_Content, rhs: Sync_ServerMessage.EntityEvent.OneOf_Content) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.create, .create): return {
          guard case .create(let l) = lhs, case .create(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.update, .update): return {
          guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.delete, .delete): return {
          guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct Create {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var clientSideID: Int64 = 0

      public var body: Sync_ServerMessage.EntityBody {
        get {return _body ?? Sync_ServerMessage.EntityBody()}
        set {_body = newValue}
      }
      /// Returns true if `body` has been explicitly set.
      public var hasBody: Bool {return self._body != nil}
      /// Clears the value of `body`. Subsequent reads from it will return its default value.
      public mutating func clearBody() {self._body = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _body: Sync_ServerMessage.EntityBody? = nil
    }

    public struct Update {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var body: Sync_ServerMessage.EntityBody {
        get {return _body ?? Sync_ServerMessage.EntityBody()}
        set {_body = newValue}
      }
      /// Returns true if `body` has been explicitly set.
      public var hasBody: Bool {return self._body != nil}
      /// Clears the value of `body`. Subsequent reads from it will return its default value.
      public mutating func clearBody() {self._body = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _body: Sync_ServerMessage.EntityBody? = nil
    }

    public struct Delete {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct EntityUpdateBatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var batchID: String = String()

    public var entityUpdates: [Sync_ServerMessage.EntityEvent] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ServerHello {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var canResume: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ResetResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var confirmedActionIds: [String] = []

    public var entityUpdates: Sync_ServerMessage.EntityUpdateBatch {
      get {return _entityUpdates ?? Sync_ServerMessage.EntityUpdateBatch()}
      set {_entityUpdates = newValue}
    }
    /// Returns true if `entityUpdates` has been explicitly set.
    public var hasEntityUpdates: Bool {return self._entityUpdates != nil}
    /// Clears the value of `entityUpdates`. Subsequent reads from it will return its default value.
    public mutating func clearEntityUpdates() {self._entityUpdates = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityUpdates: Sync_ServerMessage.EntityUpdateBatch? = nil
  }

  public struct ResumeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var success: Bool = false

    public var lastConfirmedActionID: String = String()

    public var entityUpdates: Sync_ServerMessage.EntityUpdateBatch {
      get {return _entityUpdates ?? Sync_ServerMessage.EntityUpdateBatch()}
      set {_entityUpdates = newValue}
    }
    /// Returns true if `entityUpdates` has been explicitly set.
    public var hasEntityUpdates: Bool {return self._entityUpdates != nil}
    /// Clears the value of `entityUpdates`. Subsequent reads from it will return its default value.
    public mutating func clearEntityUpdates() {self._entityUpdates = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityUpdates: Sync_ServerMessage.EntityUpdateBatch? = nil
  }

  public struct ActionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionID: String = String()

    public var success: Bool = false

    public var entityUpdates: Sync_ServerMessage.EntityUpdateBatch {
      get {return _entityUpdates ?? Sync_ServerMessage.EntityUpdateBatch()}
      set {_entityUpdates = newValue}
    }
    /// Returns true if `entityUpdates` has been explicitly set.
    public var hasEntityUpdates: Bool {return self._entityUpdates != nil}
    /// Clears the value of `entityUpdates`. Subsequent reads from it will return its default value.
    public mutating func clearEntityUpdates() {self._entityUpdates = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityUpdates: Sync_ServerMessage.EntityUpdateBatch? = nil
  }

  public struct EntityUpdateNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var entityUpdates: Sync_ServerMessage.EntityUpdateBatch {
      get {return _entityUpdates ?? Sync_ServerMessage.EntityUpdateBatch()}
      set {_entityUpdates = newValue}
    }
    /// Returns true if `entityUpdates` has been explicitly set.
    public var hasEntityUpdates: Bool {return self._entityUpdates != nil}
    /// Clears the value of `entityUpdates`. Subsequent reads from it will return its default value.
    public mutating func clearEntityUpdates() {self._entityUpdates = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityUpdates: Sync_ServerMessage.EntityUpdateBatch? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sync"

extension Sync_ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resetRequest"),
    2: .same(proto: "resumeRequest"),
    3: .same(proto: "actionRequest"),
    4: .same(proto: "entityUpdateAcknowledgement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sync_ClientMessage.ResetRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resetRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resetRequest(v)}
      }()
      case 2: try {
        var v: Sync_ClientMessage.ResumeRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resumeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resumeRequest(v)}
      }()
      case 3: try {
        var v: Sync_ClientMessage.ActionRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .actionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .actionRequest(v)}
      }()
      case 4: try {
        var v: Sync_ClientMessage.EntityUpdateAcknowledgement?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .entityUpdateAcknowledgement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .entityUpdateAcknowledgement(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .resetRequest?: try {
      guard case .resetRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resumeRequest?: try {
      guard case .resumeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .actionRequest?: try {
      guard case .actionRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .entityUpdateAcknowledgement?: try {
      guard case .entityUpdateAcknowledgement(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage, rhs: Sync_ClientMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.protoMessageName + ".ResetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localActionIds"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.localActionIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localActionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localActionIds, fieldNumber: 1)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ResetRequest, rhs: Sync_ClientMessage.ResetRequest) -> Bool {
    if lhs.localActionIds != rhs.localActionIds {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ResetRequest.EntityMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ResetRequest.protoMessageName + ".EntityMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.Google_Protobuf_Timestamp>.self, value: &self.counter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.counter.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.Google_Protobuf_Timestamp>.self, value: self.counter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ResetRequest.EntityMetadata, rhs: Sync_ClientMessage.ResetRequest.EntityMetadata) -> Bool {
    if lhs.counter != rhs.counter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.protoMessageName + ".ResumeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastProcessedEntityUpdateBatchId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastProcessedEntityUpdateBatchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastProcessedEntityUpdateBatchID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastProcessedEntityUpdateBatchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ResumeRequest, rhs: Sync_ClientMessage.ResumeRequest) -> Bool {
    if lhs.lastProcessedEntityUpdateBatchID != rhs.lastProcessedEntityUpdateBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.protoMessageName + ".ActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionId"),
    3: .same(proto: "create"),
    4: .same(proto: "delete"),
    5: .same(proto: "increment"),
    6: .same(proto: "decrement"),
    7: .same(proto: "setValue"),
    8: .same(proto: "rename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 3: try {
        var v: Sync_ClientMessage.ActionRequest.CreateCounter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .create(v)}
      }()
      case 4: try {
        var v: Sync_ClientMessage.ActionRequest.DeleteCounter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .delete(v)}
      }()
      case 5: try {
        var v: Sync_ClientMessage.ActionRequest.IncrementCounter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .increment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .increment(v)}
      }()
      case 6: try {
        var v: Sync_ClientMessage.ActionRequest.DecrementCounter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .decrement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .decrement(v)}
      }()
      case 7: try {
        var v: Sync_ClientMessage.ActionRequest.SetCounterValue?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .setValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .setValue(v)}
      }()
      case 8: try {
        var v: Sync_ClientMessage.ActionRequest.RenameCounter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .rename(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .rename(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .create?: try {
      guard case .create(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .increment?: try {
      guard case .increment(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .decrement?: try {
      guard case .decrement(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .setValue?: try {
      guard case .setValue(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .rename?: try {
      guard case .rename(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest, rhs: Sync_ClientMessage.ActionRequest) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.IncrementCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".IncrementCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.IncrementCounter, rhs: Sync_ClientMessage.ActionRequest.IncrementCounter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.DecrementCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".DecrementCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.DecrementCounter, rhs: Sync_ClientMessage.ActionRequest.DecrementCounter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.SetCounterValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".SetCounterValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.SetCounterValue, rhs: Sync_ClientMessage.ActionRequest.SetCounterValue) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.CreateCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".CreateCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientSideId"),
    2: .same(proto: "name"),
    3: .same(proto: "initialValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientSideID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.initialValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientSideID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientSideID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.initialValue != 0 {
      try visitor.visitSingularInt64Field(value: self.initialValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.CreateCounter, rhs: Sync_ClientMessage.ActionRequest.CreateCounter) -> Bool {
    if lhs.clientSideID != rhs.clientSideID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.initialValue != rhs.initialValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.DeleteCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".DeleteCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.DeleteCounter, rhs: Sync_ClientMessage.ActionRequest.DeleteCounter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.ActionRequest.RenameCounter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.ActionRequest.protoMessageName + ".RenameCounter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "newName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.ActionRequest.RenameCounter, rhs: Sync_ClientMessage.ActionRequest.RenameCounter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ClientMessage.EntityUpdateAcknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ClientMessage.protoMessageName + ".EntityUpdateAcknowledgement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batchId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ClientMessage.EntityUpdateAcknowledgement, rhs: Sync_ClientMessage.EntityUpdateAcknowledgement) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serverHello"),
    2: .same(proto: "resetResponse"),
    3: .same(proto: "resumeResponse"),
    4: .same(proto: "actionResponse"),
    5: .same(proto: "entityUpdateNotification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sync_ServerMessage.ServerHello?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .serverHello(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .serverHello(v)}
      }()
      case 2: try {
        var v: Sync_ServerMessage.ResetResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resetResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resetResponse(v)}
      }()
      case 3: try {
        var v: Sync_ServerMessage.ResumeResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resumeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resumeResponse(v)}
      }()
      case 4: try {
        var v: Sync_ServerMessage.ActionResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .actionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .actionResponse(v)}
      }()
      case 5: try {
        var v: Sync_ServerMessage.EntityUpdateNotification?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .entityUpdateNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .entityUpdateNotification(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .serverHello?: try {
      guard case .serverHello(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resetResponse?: try {
      guard case .resetResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .resumeResponse?: try {
      guard case .resumeResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .actionResponse?: try {
      guard case .actionResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .entityUpdateNotification?: try {
      guard case .entityUpdateNotification(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage, rhs: Sync_ServerMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".EntityBody"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sync_ServerMessage.EntityBody.Counter?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .counter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .counter(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .counter(let v)? = self.content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityBody, rhs: Sync_ServerMessage.EntityBody) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityBody.Counter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.EntityBody.protoMessageName + ".Counter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityBody.Counter, rhs: Sync_ServerMessage.EntityBody.Counter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".EntityEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "create"),
    4: .same(proto: "update"),
    5: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try {
        var v: Sync_ServerMessage.EntityEvent.Create?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .create(v)}
      }()
      case 4: try {
        var v: Sync_ServerMessage.EntityEvent.Update?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .update(v)}
      }()
      case 5: try {
        var v: Sync_ServerMessage.EntityEvent.Delete?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .delete(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .create?: try {
      guard case .create(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .update?: try {
      guard case .update(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityEvent, rhs: Sync_ServerMessage.EntityEvent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.EntityEvent.protoMessageName + ".Create"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientSideId"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientSideID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientSideID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientSideID, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityEvent.Create, rhs: Sync_ServerMessage.EntityEvent.Create) -> Bool {
    if lhs.clientSideID != rhs.clientSideID {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.EntityEvent.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityEvent.Update, rhs: Sync_ServerMessage.EntityEvent.Update) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.EntityEvent.protoMessageName + ".Delete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityEvent.Delete, rhs: Sync_ServerMessage.EntityEvent.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityUpdateBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".EntityUpdateBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batchId"),
    2: .same(proto: "entityUpdates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entityUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    if !self.entityUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityUpdateBatch, rhs: Sync_ServerMessage.EntityUpdateBatch) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.entityUpdates != rhs.entityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.ServerHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".ServerHello"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "canResume"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.canResume) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.canResume != false {
      try visitor.visitSingularBoolField(value: self.canResume, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.ServerHello, rhs: Sync_ServerMessage.ServerHello) -> Bool {
    if lhs.canResume != rhs.canResume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.ResetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".ResetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confirmedActionIds"),
    2: .same(proto: "entityUpdates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.confirmedActionIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entityUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.confirmedActionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.confirmedActionIds, fieldNumber: 1)
    }
    if let v = self._entityUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.ResetResponse, rhs: Sync_ServerMessage.ResetResponse) -> Bool {
    if lhs.confirmedActionIds != rhs.confirmedActionIds {return false}
    if lhs._entityUpdates != rhs._entityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.ResumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".ResumeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "lastConfirmedActionId"),
    3: .same(proto: "entityUpdates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastConfirmedActionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._entityUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.lastConfirmedActionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastConfirmedActionID, fieldNumber: 2)
    }
    if let v = self._entityUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.ResumeResponse, rhs: Sync_ServerMessage.ResumeResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.lastConfirmedActionID != rhs.lastConfirmedActionID {return false}
    if lhs._entityUpdates != rhs._entityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.ActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".ActionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionId"),
    2: .same(proto: "success"),
    3: .same(proto: "entityUpdates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._entityUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if let v = self._entityUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.ActionResponse, rhs: Sync_ServerMessage.ActionResponse) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.success != rhs.success {return false}
    if lhs._entityUpdates != rhs._entityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_ServerMessage.EntityUpdateNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_ServerMessage.protoMessageName + ".EntityUpdateNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entityUpdates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityUpdates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entityUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_ServerMessage.EntityUpdateNotification, rhs: Sync_ServerMessage.EntityUpdateNotification) -> Bool {
    if lhs._entityUpdates != rhs._entityUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
