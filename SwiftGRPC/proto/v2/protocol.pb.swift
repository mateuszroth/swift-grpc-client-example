// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Sync_Protocol_EntityMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Sync_Protocol_TypedEntityMetadataList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeID: String = String()

  public var entries: [Sync_Protocol_EntityMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Sync_Protocol_TypedEntityMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var typeID: String = String()

  public var entityMetadata: Sync_Protocol_EntityMetadata {
    get {return _entityMetadata ?? Sync_Protocol_EntityMetadata()}
    set {_entityMetadata = newValue}
  }
  /// Returns true if `entityMetadata` has been explicitly set.
  public var hasEntityMetadata: Bool {return self._entityMetadata != nil}
  /// Clears the value of `entityMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearEntityMetadata() {self._entityMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entityMetadata: Sync_Protocol_EntityMetadata? = nil
}

public struct Sync_Protocol_EntityEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entityMetadata: Sync_Protocol_TypedEntityMetadata {
    get {return _entityMetadata ?? Sync_Protocol_TypedEntityMetadata()}
    set {_entityMetadata = newValue}
  }
  /// Returns true if `entityMetadata` has been explicitly set.
  public var hasEntityMetadata: Bool {return self._entityMetadata != nil}
  /// Clears the value of `entityMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearEntityMetadata() {self._entityMetadata = nil}

  public var content: Sync_Protocol_EntityEvent.OneOf_Content? = nil

  public var create: Sync_Protocol_EntityEvent.Create {
    get {
      if case .create(let v)? = content {return v}
      return Sync_Protocol_EntityEvent.Create()
    }
    set {content = .create(newValue)}
  }

  public var update: Sync_Protocol_EntityEvent.Update {
    get {
      if case .update(let v)? = content {return v}
      return Sync_Protocol_EntityEvent.Update()
    }
    set {content = .update(newValue)}
  }

  public var delete: Sync_Protocol_EntityEvent.Delete {
    get {
      if case .delete(let v)? = content {return v}
      return Sync_Protocol_EntityEvent.Delete()
    }
    set {content = .delete(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case create(Sync_Protocol_EntityEvent.Create)
    case update(Sync_Protocol_EntityEvent.Update)
    case delete(Sync_Protocol_EntityEvent.Delete)

  #if !swift(>=4.1)
    public static func ==(lhs: Sync_Protocol_EntityEvent.OneOf_Content, rhs: Sync_Protocol_EntityEvent.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.create, .create): return {
        guard case .create(let l) = lhs, case .create(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct Create {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Entities created by the client will have their ID replaced by a server-generated one. We send it here
    /// to let the client resolve the situation. Zero means null.
    public var clientSideID: Int64 = 0

    /// The actual entity data types are defined in entities.proto.
    /// The any type is expressed as a type ID (usually URI, but may be any kind of unique string), and a valid Protobuf
    /// byte string representing the object.
    public var body: SwiftProtobuf.Google_Protobuf_Any {
      get {return _body ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    public var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    public mutating func clearBody() {self._body = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _body: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  public struct Update {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var body: SwiftProtobuf.Google_Protobuf_Any {
      get {return _body ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    public var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    public mutating func clearBody() {self._body = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _body: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  public struct Delete {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _entityMetadata: Sync_Protocol_TypedEntityMetadata? = nil
}

public struct Sync_Protocol_EntityEventBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var batchID: String = String()

  public var entityEvents: [Sync_Protocol_EntityEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Sync_Protocol_ClientMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Sync_Protocol_ClientMessage.OneOf_Content? = nil

  public var resetRequest: Sync_Protocol_ClientMessage.ResetRequest {
    get {
      if case .resetRequest(let v)? = content {return v}
      return Sync_Protocol_ClientMessage.ResetRequest()
    }
    set {content = .resetRequest(newValue)}
  }

  public var resumeRequest: Sync_Protocol_ClientMessage.ResumeRequest {
    get {
      if case .resumeRequest(let v)? = content {return v}
      return Sync_Protocol_ClientMessage.ResumeRequest()
    }
    set {content = .resumeRequest(newValue)}
  }

  public var actionRequest: Sync_Protocol_ClientMessage.ActionRequest {
    get {
      if case .actionRequest(let v)? = content {return v}
      return Sync_Protocol_ClientMessage.ActionRequest()
    }
    set {content = .actionRequest(newValue)}
  }

  public var entityEventAcknowledgement: Sync_Protocol_ClientMessage.EntityEventAcknowledgement {
    get {
      if case .entityEventAcknowledgement(let v)? = content {return v}
      return Sync_Protocol_ClientMessage.EntityEventAcknowledgement()
    }
    set {content = .entityEventAcknowledgement(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case resetRequest(Sync_Protocol_ClientMessage.ResetRequest)
    case resumeRequest(Sync_Protocol_ClientMessage.ResumeRequest)
    case actionRequest(Sync_Protocol_ClientMessage.ActionRequest)
    case entityEventAcknowledgement(Sync_Protocol_ClientMessage.EntityEventAcknowledgement)

  #if !swift(>=4.1)
    public static func ==(lhs: Sync_Protocol_ClientMessage.OneOf_Content, rhs: Sync_Protocol_ClientMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resetRequest, .resetRequest): return {
        guard case .resetRequest(let l) = lhs, case .resetRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeRequest, .resumeRequest): return {
        guard case .resumeRequest(let l) = lhs, case .resumeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionRequest, .actionRequest): return {
        guard case .actionRequest(let l) = lhs, case .actionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entityEventAcknowledgement, .entityEventAcknowledgement): return {
        guard case .entityEventAcknowledgement(let l) = lhs, case .entityEventAcknowledgement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Wipes server-side cache and re-syncs the data.
  /// Passing an empty map in the localTimestamps field effectively makes the server re-send the entire state.
  public struct ResetRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// IDs of all unsynced actions
    public var localActionIds: [String] = []

    /// metadata (type + id + timestamp) of every entity that the mobile app knows about
    public var metadata: [Sync_Protocol_TypedEntityMetadataList] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// a lightweight way to resume a connection if the backend still keeps its state in the cache.
  public struct ResumeRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// last entity Event batch processed by the client.z
    public var lastProcessedEntityEventBatchID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// represents an atomic action that should be applied as transaction.
  public struct ActionRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionID: String = String()

    /// The actual action data types are defined in actions.proto
    public var content: SwiftProtobuf.Google_Protobuf_Any {
      get {return _content ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    public var hasContent: Bool {return self._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating func clearContent() {self._content = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _content: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  /// Lets the server know that a given entity event batch was processed successfully.
  /// This applies to action results too!
  public struct EntityEventAcknowledgement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var batchID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Sync_Protocol_ServerMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: Sync_Protocol_ServerMessage.OneOf_Content? = nil

  public var resetResponse: Sync_Protocol_ServerMessage.ResetResponse {
    get {
      if case .resetResponse(let v)? = content {return v}
      return Sync_Protocol_ServerMessage.ResetResponse()
    }
    set {content = .resetResponse(newValue)}
  }

  public var resumeResponse: Sync_Protocol_ServerMessage.ResumeResponse {
    get {
      if case .resumeResponse(let v)? = content {return v}
      return Sync_Protocol_ServerMessage.ResumeResponse()
    }
    set {content = .resumeResponse(newValue)}
  }

  public var actionResponse: Sync_Protocol_ServerMessage.ActionResponse {
    get {
      if case .actionResponse(let v)? = content {return v}
      return Sync_Protocol_ServerMessage.ActionResponse()
    }
    set {content = .actionResponse(newValue)}
  }

  public var entityEventNotification: Sync_Protocol_ServerMessage.EntityEventNotification {
    get {
      if case .entityEventNotification(let v)? = content {return v}
      return Sync_Protocol_ServerMessage.EntityEventNotification()
    }
    set {content = .entityEventNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case resetResponse(Sync_Protocol_ServerMessage.ResetResponse)
    case resumeResponse(Sync_Protocol_ServerMessage.ResumeResponse)
    case actionResponse(Sync_Protocol_ServerMessage.ActionResponse)
    case entityEventNotification(Sync_Protocol_ServerMessage.EntityEventNotification)

  #if !swift(>=4.1)
    public static func ==(lhs: Sync_Protocol_ServerMessage.OneOf_Content, rhs: Sync_Protocol_ServerMessage.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resetResponse, .resetResponse): return {
        guard case .resetResponse(let l) = lhs, case .resetResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeResponse, .resumeResponse): return {
        guard case .resumeResponse(let l) = lhs, case .resumeResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionResponse, .actionResponse): return {
        guard case .actionResponse(let l) = lhs, case .actionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.entityEventNotification, .entityEventNotification): return {
        guard case .entityEventNotification(let l) = lhs, case .entityEventNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ResetResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// allows the client to clear actions that have been sent to the server, but were not confirmed,
    /// for ex. because of connection drop
    public var confirmedActionIds: [String] = []

    /// all entities that the mobile needs but does not have, according to the metadata from the reset request
    public var entityEvents: Sync_Protocol_EntityEventBatch {
      get {return _entityEvents ?? Sync_Protocol_EntityEventBatch()}
      set {_entityEvents = newValue}
    }
    /// Returns true if `entityEvents` has been explicitly set.
    public var hasEntityEvents: Bool {return self._entityEvents != nil}
    /// Clears the value of `entityEvents`. Subsequent reads from it will return its default value.
    public mutating func clearEntityEvents() {self._entityEvents = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityEvents: Sync_Protocol_EntityEventBatch? = nil
  }

  public struct ResumeResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// because actions are processed serially, at most one action can be unconfirmed during a connection.
    /// this field allows the client to clear the action that was recently sent but not confirmed yet.
    public var lastConfirmedActionID: String = String()

    /// all entity Events that happened since the previous session was interrupted.
    public var entityEvents: Sync_Protocol_EntityEventBatch {
      get {return _entityEvents ?? Sync_Protocol_EntityEventBatch()}
      set {_entityEvents = newValue}
    }
    /// Returns true if `entityEvents` has been explicitly set.
    public var hasEntityEvents: Bool {return self._entityEvents != nil}
    /// Clears the value of `entityEvents`. Subsequent reads from it will return its default value.
    public mutating func clearEntityEvents() {self._entityEvents = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityEvents: Sync_Protocol_EntityEventBatch? = nil
  }

  public struct ActionResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionID: String = String()

    public var success: Bool = false

    /// all entities that were affected by the action
    public var entityEvents: Sync_Protocol_EntityEventBatch {
      get {return _entityEvents ?? Sync_Protocol_EntityEventBatch()}
      set {_entityEvents = newValue}
    }
    /// Returns true if `entityEvents` has been explicitly set.
    public var hasEntityEvents: Bool {return self._entityEvents != nil}
    /// Clears the value of `entityEvents`. Subsequent reads from it will return its default value.
    public mutating func clearEntityEvents() {self._entityEvents = nil}

    /// optional, intended to be shown to the user
    public var errorMessage: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityEvents: Sync_Protocol_EntityEventBatch? = nil
  }

  /// notifies the client about entity updates relevant to the client
  public struct EntityEventNotification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var entityEvents: Sync_Protocol_EntityEventBatch {
      get {return _entityEvents ?? Sync_Protocol_EntityEventBatch()}
      set {_entityEvents = newValue}
    }
    /// Returns true if `entityEvents` has been explicitly set.
    public var hasEntityEvents: Bool {return self._entityEvents != nil}
    /// Clears the value of `entityEvents`. Subsequent reads from it will return its default value.
    public mutating func clearEntityEvents() {self._entityEvents = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _entityEvents: Sync_Protocol_EntityEventBatch? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sync.protocol"

extension Sync_Protocol_EntityMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityMetadata, rhs: Sync_Protocol_EntityMetadata) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_TypedEntityMetadataList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypedEntityMetadataList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeId"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.typeID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeID.isEmpty {
      try visitor.visitSingularStringField(value: self.typeID, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_TypedEntityMetadataList, rhs: Sync_Protocol_TypedEntityMetadataList) -> Bool {
    if lhs.typeID != rhs.typeID {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_TypedEntityMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypedEntityMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "typeId"),
    2: .same(proto: "entityMetadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.typeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entityMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typeID.isEmpty {
      try visitor.visitSingularStringField(value: self.typeID, fieldNumber: 1)
    }
    if let v = self._entityMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_TypedEntityMetadata, rhs: Sync_Protocol_TypedEntityMetadata) -> Bool {
    if lhs.typeID != rhs.typeID {return false}
    if lhs._entityMetadata != rhs._entityMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_EntityEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entityMetadata"),
    2: .same(proto: "create"),
    3: .same(proto: "update"),
    4: .same(proto: "delete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityMetadata) }()
      case 2: try {
        var v: Sync_Protocol_EntityEvent.Create?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .create(v)}
      }()
      case 3: try {
        var v: Sync_Protocol_EntityEvent.Update?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .update(v)}
      }()
      case 4: try {
        var v: Sync_Protocol_EntityEvent.Delete?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .delete(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entityMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .create?: try {
      guard case .create(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .update?: try {
      guard case .update(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityEvent, rhs: Sync_Protocol_EntityEvent) -> Bool {
    if lhs._entityMetadata != rhs._entityMetadata {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_EntityEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_EntityEvent.protoMessageName + ".Create"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clientSideId"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clientSideID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clientSideID != 0 {
      try visitor.visitSingularInt64Field(value: self.clientSideID, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityEvent.Create, rhs: Sync_Protocol_EntityEvent.Create) -> Bool {
    if lhs.clientSideID != rhs.clientSideID {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_EntityEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_EntityEvent.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityEvent.Update, rhs: Sync_Protocol_EntityEvent.Update) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_EntityEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_EntityEvent.protoMessageName + ".Delete"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityEvent.Delete, rhs: Sync_Protocol_EntityEvent.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_EntityEventBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntityEventBatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batchId"),
    2: .same(proto: "entityEvents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entityEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    if !self.entityEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entityEvents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_EntityEventBatch, rhs: Sync_Protocol_EntityEventBatch) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.entityEvents != rhs.entityEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ClientMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resetRequest"),
    2: .same(proto: "resumeRequest"),
    3: .same(proto: "actionRequest"),
    4: .same(proto: "entityEventAcknowledgement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sync_Protocol_ClientMessage.ResetRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resetRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resetRequest(v)}
      }()
      case 2: try {
        var v: Sync_Protocol_ClientMessage.ResumeRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resumeRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resumeRequest(v)}
      }()
      case 3: try {
        var v: Sync_Protocol_ClientMessage.ActionRequest?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .actionRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .actionRequest(v)}
      }()
      case 4: try {
        var v: Sync_Protocol_ClientMessage.EntityEventAcknowledgement?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .entityEventAcknowledgement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .entityEventAcknowledgement(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .resetRequest?: try {
      guard case .resetRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resumeRequest?: try {
      guard case .resumeRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .actionRequest?: try {
      guard case .actionRequest(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .entityEventAcknowledgement?: try {
      guard case .entityEventAcknowledgement(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ClientMessage, rhs: Sync_Protocol_ClientMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ClientMessage.ResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ClientMessage.protoMessageName + ".ResetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localActionIds"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.localActionIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localActionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.localActionIds, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ClientMessage.ResetRequest, rhs: Sync_Protocol_ClientMessage.ResetRequest) -> Bool {
    if lhs.localActionIds != rhs.localActionIds {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ClientMessage.ResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ClientMessage.protoMessageName + ".ResumeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastProcessedEntityEventBatchId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastProcessedEntityEventBatchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastProcessedEntityEventBatchID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastProcessedEntityEventBatchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ClientMessage.ResumeRequest, rhs: Sync_Protocol_ClientMessage.ResumeRequest) -> Bool {
    if lhs.lastProcessedEntityEventBatchID != rhs.lastProcessedEntityEventBatchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ClientMessage.ActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ClientMessage.protoMessageName + ".ActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionId"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ClientMessage.ActionRequest, rhs: Sync_Protocol_ClientMessage.ActionRequest) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ClientMessage.EntityEventAcknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ClientMessage.protoMessageName + ".EntityEventAcknowledgement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "batchId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.batchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.batchID.isEmpty {
      try visitor.visitSingularStringField(value: self.batchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ClientMessage.EntityEventAcknowledgement, rhs: Sync_Protocol_ClientMessage.EntityEventAcknowledgement) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ServerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resetResponse"),
    2: .same(proto: "resumeResponse"),
    3: .same(proto: "actionResponse"),
    4: .same(proto: "entityEventNotification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Sync_Protocol_ServerMessage.ResetResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resetResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resetResponse(v)}
      }()
      case 2: try {
        var v: Sync_Protocol_ServerMessage.ResumeResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .resumeResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .resumeResponse(v)}
      }()
      case 3: try {
        var v: Sync_Protocol_ServerMessage.ActionResponse?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .actionResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .actionResponse(v)}
      }()
      case 4: try {
        var v: Sync_Protocol_ServerMessage.EntityEventNotification?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .entityEventNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .entityEventNotification(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .resetResponse?: try {
      guard case .resetResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resumeResponse?: try {
      guard case .resumeResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .actionResponse?: try {
      guard case .actionResponse(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .entityEventNotification?: try {
      guard case .entityEventNotification(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ServerMessage, rhs: Sync_Protocol_ServerMessage) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ServerMessage.ResetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ServerMessage.protoMessageName + ".ResetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "confirmedActionIds"),
    2: .same(proto: "entityEvents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.confirmedActionIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entityEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.confirmedActionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.confirmedActionIds, fieldNumber: 1)
    }
    if let v = self._entityEvents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ServerMessage.ResetResponse, rhs: Sync_Protocol_ServerMessage.ResetResponse) -> Bool {
    if lhs.confirmedActionIds != rhs.confirmedActionIds {return false}
    if lhs._entityEvents != rhs._entityEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ServerMessage.ResumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ServerMessage.protoMessageName + ".ResumeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "lastConfirmedActionId"),
    3: .same(proto: "entityEvents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.lastConfirmedActionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._entityEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastConfirmedActionID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastConfirmedActionID, fieldNumber: 2)
    }
    if let v = self._entityEvents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ServerMessage.ResumeResponse, rhs: Sync_Protocol_ServerMessage.ResumeResponse) -> Bool {
    if lhs.lastConfirmedActionID != rhs.lastConfirmedActionID {return false}
    if lhs._entityEvents != rhs._entityEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ServerMessage.ActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ServerMessage.protoMessageName + ".ActionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionId"),
    2: .same(proto: "success"),
    3: .same(proto: "entityEvents"),
    4: .same(proto: "errorMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._entityEvents) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if let v = self._entityEvents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ServerMessage.ActionResponse, rhs: Sync_Protocol_ServerMessage.ActionResponse) -> Bool {
    if lhs.actionID != rhs.actionID {return false}
    if lhs.success != rhs.success {return false}
    if lhs._entityEvents != rhs._entityEvents {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Protocol_ServerMessage.EntityEventNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Sync_Protocol_ServerMessage.protoMessageName + ".EntityEventNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entityEvents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entityEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entityEvents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Sync_Protocol_ServerMessage.EntityEventNotification, rhs: Sync_Protocol_ServerMessage.EntityEventNotification) -> Bool {
    if lhs._entityEvents != rhs._entityEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
